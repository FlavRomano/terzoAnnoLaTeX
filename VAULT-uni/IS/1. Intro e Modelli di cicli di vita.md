# Introduzione
* **Fault tolerance**. Dopo che si rompe torna normale. Un sw dopo un crash deve poter ripartire da uno stato consistente.

* **Robustezza**. Non si rompe. Un sw che è in grado di funzionare correttamente anche con un utente sbadato (mette input inaspettati).

* **Difetto latente**. Un bug o *baco*. Problema nel sw che sfugge al testing e magari anche all'utilizzatore.

* **Stackholders**. figure che hanno interesse nello sviluppo:
	* **Fornitore**. chi sviluppa
	* **Committente** chi richiede, e paga, il sw.
	* **Utente** chi lo usa.

# Il processo software: Modelli di cicli di vita
Con processo software si indica il percorso da svolgere per sviluppare un prodotto o sistema software. Inizia con l’esplorazione dell’idea e finisce con la dismissione del software include anche gli strumenti e le tecniche per lo sviluppo e i professionisti coinvolti.
Modellare il processo significa strutturarlo, cioè suddividerlo in **attività** e specificare per ognugna di esse:
* Cosa fa.
* Di quali prodotti si occupa.
* Quando viene attuata.
## Modello di ciclo di vita
Non è altro che un modo per organizzare le attività e determinare quando un'attività è terminata e bisogna passsare alla successiva.
### Build & Fix (non modello)
Letteralmente costruisci e aggiusta, va bene per progetti con $\leq100$ linee di codice. Il prodotto è sviluppato senza specifica e senza un tentativo di progettazione lo sviluppatore scrive un programma che poi è modificato più volte finché non soddisfa il committente. La manutenzione di un prodotto senza specifica o documentazione che ne spieghi la progettazione è estremamente difficile.

--------------------------
### Modello a cascata di Royce
![[modello_cascata_royce.png]]
Il valore di questo modello è stato quello di distinguere e definire le fasi di un processo software. Evidenziando l’importanza delle fasi di analisi e di progettazione prima di passare alla codifica. Inoltre il modello richiede che il passaggio a una nuova fase sia possibile solo dopo il completamento della precedente. Ogni fase produce un documento che deve essere approvato da un gruppo di valutatori prima di passare alla fase successiva. Si parla anche di modello **document driven**.
```ad-warning
title: Criticità
* Eccessiva produzione di documenti.
* Sequenzialità rigida (solo cicli in avanti, no cicli all'indietro).
* Zero feedback del cliente, vede solo il prodotto finito e spesso c'è differenza tra esso e l'idea del cliente.
```
```ad-hint
title: Pregi
* Fasi ben ordinate da seguire per strutturare un processo sw.
* C'è da dire che un modello successivo ideato da Royce prevedeva dei *feedback loops*, aggiungendo un correttivo importante ad un problemo non poco degno di nota.
```
--------------------
### Modello a V
![[v-model.png]]
La cascata a V mette allo stesso livello fasi che corrispondono. Notiamo che le linee tratteggiate indicano le **dipendenze causali** mentre la linea blu (che forma la V) indica il **tempo**. Soffermiamoci sul primo livello:
>Evidenzia come sia possibile progettare i test durante le fasi di sviluppo (prima della codifica). 

Il modello a V prende la metà inferiore del modello a cascata e la piega verso l'alto a forma di V. Le attività a *destra* verificano o convalidano i prodotti dell'attività a *sinistra*. Il lato sinistro della V rappresenta le attività di analisi che scompongono le esigenze degli utenti in pezzi piccoli e gestibili. Mentre il lato destro della V mostra le corrispondenti attività di sintesi che aggregano (e testano) questi pezzi in un sistema che soddisfa le esigenze degli utenti
La progettazione di test diventa parte integrante del processo di sviluppo di un sw.
Dall'idea del modello a V nasce il modello di sviluppo **Test Driven Development**.

Sia il modello a cascata che quello a V sono noti come ==Modelli fondamentalmente sequenziali==. Osserviamone alcuni appartenenti alla categoria dei ==Modelli iterativi==.

-------------
### Rapid prototyping (o evolutivo)
![[rapid-prototyping.png]]
I requisiti dati dal cliente potrebbero non essere sempre chiari. Per evitare misunderstanding diamo un **prototipo** per assicurarci che il lavoro fatto fin'ora soddisfi la richiesta del cliente. È un potente strumento che aiuta anche il cliente a descrivere meglio i requisiti del sw.

----------
### Modello incrementale
![[Modello-incrementale.png]]
Consigliato quando voglio fornire al cliente le funzionalità importanti del prodotto, poi man mano aggiungo feature. I requisiti e il progetto devono essere ben definiti inizialmente. Il sistema è implementato, integrato e testato con una serie di passaggi incrementali.
```ad-hint
title: Pregi
* Posso ritardare la realizzazione delle componenti che dipendono criticamente da fattori esterni (tecnologie, hardware sperimentale, ecc).
* Posso dare velocemente qualcosa al cliente di funzionante.
```
```ad-warning
Se non progettato bene diventa un Build-and-Fix.
```
--------------
### Modello a spirale di Boehm
![[modello-spirale.png]]
Nasce dal modello ==Plan-Check-Act== dell'economia. Si itera su 4 step:
1. Definizione degli obiettivi, vincoli, alternative.
2. Analisi dei rischi e valutazione delle alternative.
3. Sviluppo e validazione del prodotto.
4. Pianificazione del nuovo ciclo.

La particolarità di questo modello è che si sofferma sui aspetti gestionali del processo di sviluppo. È centrato sull'analisi dei rischi e prevede maggior comunicazione con il committente.
## Processi agili
Per metodologia agile (o leggera) o metodo agile si intende un particolare metodo per lo sviluppo del software che coinvolge quanto più possibile il committente. Adatti a progetti con meno di 50 svilupatori Una metodologia agile si basa sui principi del Manifesto di Snowbird.
### Agile manifesto (Snowbird)
Nel 2001 viene definito questo manifesto, che non è un modello di ciclo di vita.
Si basa su: **comunicazione**, **semplicità**, **feedback** e **coraggio**.
```ad-abstract
title: Comunicazione
È più importante la comunicazione col cliente che gli strumenti che si utilizzano. Viene sovvertito il sistema gerarchico del team, tutti possono parlare col cliente. È fondamentale collaborare con i clienti al di là del contratto, la collaborazione diretta offre risultati migliori dei rapporti contrattuali.
```
```ad-abstract
title: Semplicità
Il software deve essere semplice e funzionale, con una documentazione semplice e snella. 
```
```ad-abstract
title: Feedback
È fondamentale rilasciare prototipi al cliente per capire se il lavoro fatto fin'ora è congruo alle sue aspettative o meno.
```
```ad-abstract
title: Coraggio
È conveniente rilasciare il software il prima possibile e implementare successivamente i cambiamenti richiesti.
```
### eXtreme Programming
È un esempio di processo Agile che si basa su un insieme di prassi:
1. **Pianificazione flessibile.** basata su scenari proposti dagli utenti, in modo da coinvolgere i programmatori.
2. **Rilasci frequenti.** a cadenza bimensile o mensile.
3. **Progetti semplici.**  comprensibili a tutti.
4. **Testing.** basati sugli scenari proposti dagli utenti.
5. **Test Driven Development.** proporre casi di test prima di scrivere il codice.
6. **Feedback col cliente.**  settimanalmente bisogna sentirlo per sentire la sua.
7. **Programmazione a coppie.**  uno scrittore e un correttore.
8. **No lavoro straordinario.** si è più produttivi.
9. **Collettivizzazione del codice.** che si basa su
	- Accesso libero al codice.
	- Integrazione continua.
	- Standard di codifica.
10. **Code refactoring.** se un metodo necessità di un commento, allora riscrivilo.
11. **Daily Stand-up meeting.** si perde meno tempo.
### SCRUM
È un processo Agile il cui nome deriva dalla terminologia del gioco del Rugby (mischia). Un processo in cui un insieme di persone si muove all'unisono per raggiungere un obiettivo predeterminato, tale obiettivo garantisce la soddisfazione delle ambizioni di squadra e delle ambizioni personali. È un processo:
- Che può essere adottato per gestire e controllare lo sviluppo del software.
- E’ iterativo, incrementale, per lo sviluppo e gestione di ogni tipologia di prodotto.
- Fornisce alla fine di ogni iterazione un set di funzionalità potenzialmente rilasciabili.
#### 3 fasi
1. ==**Pre-game phase**== suddivisa in
	- **Planning sub-phase.** include la definizione del sistema che deve essere sviluppato. Viene creata una Product Backlog List, che contiene tutti i requisiti attualmente conosciuti.
	- **Architecture sub-phase.** viene pianificato un design di alto livello del sistema, inclusa l’architettura, in base agli elementi contenuti nel Product Backlog.
2. ==**Developmente (Game)-phase**.== in questa fase il sistema viene sviluppato attraverso una serie di Sprint.	
> Li Sprint sono cicli iterativi nei quali vengono sviluppate o migliorate una serie di funzionalità. Uno Sprint si svolge in un intervallo di tempo che va da una settimana ad un mese. Ciascuno Sprint include le tradizionali fasi di sviluppo del software. L'architettura del sistema evolve durante lo sviluppo negli Sprint.
3. ==**Post-game phase.**== la gestione conclude il processo di sviluppo e il prodotto viene preparato per il rilascio. Questo include: Integrazione, test, doc per l'utente, formazione e preparazione del materiale di marketing.
#### 3 ruoli 
1. ==**Product owner.**== è quella figura a cui fanno riferimento tutti i soggetti interessati al progetto, compreso il cliente finale. È in grado di effettuare stime, aggiustare i processi che presentano difetti e di gestire l'intero procedimento secondo la pianificazione inizialmente fatta. I suoi poteri sono:
	- Accettare o rigettare i risultati di un lavoro.
	- Terminare uno Sprint se necessario.
2. ==**Membri del team.**== sono coloro che costruiscono il prodotto, ognuno decide cosa fare in ciascuno Sprint. Le caratteristiche fondamentali sono:
	- Cross-functional perché l’eccessiva specializzazione rischia di avere persone cariche di lavoro e altre che aspettano.
	- Team (da 7+2 persone) organizzati indipendentemente senza project (or team) manager.
	- Ognuno realizza una cosa alla volta (no multitasking).
3. ==**Scrum Master.**== figura che si occupa di supportare il team garantendo le condizioni ambientali e le motivazioni necessarie ad eseguire al meglio il lavoro commissionato. Risolve i problemi ed è un esperto del sistema Agile. Non ha autorità sul team.
#### Backlog
Lista dei requisiti (*userstory*) ancora da realizzare. Ogni sprint ha il suo backlog.
![[backlog.png]]
#### Kanban
Spazio vuoto suddiviso dalle colonne: **Not Done**, **In Progress**, **Test** e **Done**. 
Ogni kanban card rappresenta contiene informazioni preziose sul task da fare, come il riepilogo dell'incarico, la persona responsabile, la scadenza e così via. 
Troppi post-it messi *in progress* sono un problema, perché non si porta a termine nulla. Una soluzione è quella di introdurre un **WIP-limit** per evitare di avere tante cose iniziate e poche cose finite; è utile per limitare il task-switching e consegnare qualcosa al cliente.
#### Eventi di uno Sprint
1. ==**Planning.**== il product owner gestisce l'evento di pianificazione dello Sprint, che ha una durata di 8 ore; insieme al Team si definisce lo sprint backlog.
2. ==**Daily meeting.**== I membri del team si posizionano in semicerchio davanti alla kanban, gli Scrum master si posizionano nelle vicinanze. Si risponde alle domande:
	- "Cosa ho fatto ieri?"
	- "Cosa farò oggi?"
	- "Quali difficoltà sto affrontando?"
3. ==**Review.**== Incontro di 4 ore, una volta consegnato un incremento di prodotto Il team in collaborazione con gli utenti ispeziona il software per ottenere un feedback. Si discutono domande come:
	- "È questo il prodotto che vogliamo costruire?". 
	- "Cosa penserebbero gli utenti finali del prodotto?".
	- "Qual è il feedback degli utenti finali?". 
	- "È ancora il prodotto che ci è stato richiesto?". 
	- "Ci sono cambiamenti o nuove idee?".
4. ==**Retrospettiva.**== Dopo ogni Sprint, il team Scrum organizza anche un evento di retrospettiva dello Sprint di 3 ore, in modo che l'intero team Scrum possa dedicare un po' di tempo a riflettere, imparare e riadattarsi per lo Sprint successivo. L'intero scopo dell'evento di retrospettiva dello Sprint è quello di contribuire al miglioramento continuo o alla crescita continua del team Scrum.