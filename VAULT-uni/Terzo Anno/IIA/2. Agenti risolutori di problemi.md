Gli agenti di problem-solving o risolutori di problemi:
- Adottano il paradigma della risoluzione di problemi come ricerca in uno spazio di stati (problem solving).
- Sono agenti con **modello** (storia percezioni e stati) che adottano una rappresentazione atomica dello stato.
- Sono particolari agenti con **obiettivo**, che pianificano l’intera sequenza di mosse prima di agire.

```ad-def
title: Processo di risoluzione
Ha 4 passi da seguire:
1. Determinazione dell'obiettivo (cioè trovare un insieme di stati in cui l'obiettivo è soddisfatto).
2. Formulazione del problema (rappresentazione degli stati e rappresentazione delle azioni).
3. Determinazione della soluzione mediante ricerca (un piano).
4. Esecuzione del piano (soluzione algoritmica).
```
e.g Viaggio con mappa:
1. Raggiungere Bucarest
2. $Azioni = \textit{Guidare da una città all'altra}$; $Stato = \textit{Città sulla mappa}$.

```ad-help
Bisogna fare delle assunzioni:
- Ambiente statico (il mondo non cambia mentre l’agente decide l’azione, non varia nel tempo)
- Osservabile (so dove sono)
- Discreto (insieme finito di azioni possibili)
- Deterministico ($1\textit{ azione} \to 1\textit{ risultato}$), si assume che l'agente possa eseguire il piano "ad occhi chiusi", niente può andare storto (e.g da A arrivo sicuramente in B).
```
## Formulazione del problema
 Un problema può essere definito formalmente mediante cinque componenti:
 1. Stato iniziali.
 2. Azioni possibili in s: $Azioni(s)$ dove $s = stato$
 3. Modello di transizione: 
	 - $Risultato:\textit{stato}\times\textit{azione}\to\textit{stato}$
	 - $Risultato(s,a) = s'$ con $s'$ detto "stato **successore**".
4. Test obiettivo: funzione che dato uno stato restituisce un booleano in base all'obiettivo $\textit{goal-test}:stato\to\{true,false\}$
5. Costo del cammino: somma dei costi delle azioni (costo dei passi) dove
	- costo di un azione: $c(s,a,s')$ dove $a$ è un'azione.
	- il costo di un azione è sempre non negativo, $c(s,a,s') \geq 0$.

(1), (2) e (3) definiscono implicitamente lo **spazio degli stati**. 
- Definirlo esplicitamente può essere molto dispendioso.

## Algoritmi di ricerca
> Il processo che cerca una sequenza di azioni che raggiunge l’obiettivo è detto ricerca

Gli algoritmi di ricerca prendono in input un problema e restituiscono un cammino soluzione. 
e.g un cammino che porta dallo stato iniziale a uno stato goal

### Misura delle prestazioni
Trova una soluzione? Quanto costa trovarla? Quanto efficiente è la soluzione?
In generale possiamo affermare che il costo totale di un algoritmo equivale alla somma del costo della ricerca e del costo del cammino trovato:
$$ \textit{Costo totale} = \textit{Costo della ricerca} +  
\textit{Costo del cammino soluzione} $$

Ne viene che se $\textit{Costo della ricerca} > \textit{Costo del cammino soluzione}$ allora l'algoritmo utilizzato è poco efficiente.

### Caso studio: Itinerario
Vogliamo trovare il percorso più breve (in km) da una città di partenza a una città di arrivo. In questo caso vogliamo arrivare a Bucarest partendo da Arad.

![[problema_itinerario.png]]

```ad-note
title: Formulazione
- Stati: le città (e.g `In(Pitesti)`)
	1. Stato iniziale. Città da cui si parte. `In(Arad)`
	2. Azioni. Spostarsi da una città all'altra, devono essere collegate.
	 `Azioni(In(Arad)) ={Go(Sibiu), Go(Zerind) ...}`
	3. Modello di transizione. `Risultato(In(Arad), Go(Sibiu)) = In(Sibiu)`.
	4. Test Obiettivo: `{In(Bucarest)}`.
	5. Costo del cammino: somma lunghezze strade.
- Lo spazio degli stati coincide con il grafo di collegamenti tra le città.
```

### Caso studio: Gioco dell'otto

![[problema_gioco8.png]]

```ad-note
title: Formulazione
- Stati: possibili configurazioni della scacchiera
	1. Stato iniziale: una configurazione
    2. Obiettivo: una configurazione
    3. Goal-Test: Stato obiettivo?
    4. Azioni: mosse della casella bianca (su, giù, sinistra, destra)
    5. Costo cammino: ogni passo costa 1
- Lo spazio degli stati è un grafo con possibili cicli.
- È un problema NP-completo, per 8 tasselli abbiamo $\dfrac{9!}{2}=181'000$ stati.
```

### Caso studio: Le otto regine
Collocare otto regine sulla scacchiera in modo tale che nessuna regina sia attaccata da altre.

![[problema_8regine.png]]

Abbiamo diverse formulazioni possibili:

```ad-note
title: Formulazione incrementale I
- Stati: scacchiere con 0-8 regine
	1. Goal-Test: 8 regine sulla scacchiera, nessuna attaccata.
	2. Costo cammino: zero (resta 8, per le 8 mosse effettive, e non è rilevante, interessa solo lo stato finale).
	3. Azioni: aggiungi una regina
	4. Spazio stati: $64 \cdot 63 \cdot \ldots \cdot 57 \sim 1.8 \cdot 10^{14}$ possibili sequenze da considerare.
```

```ad-note
title: Formulazione incrementale II
- Stati: scacchiere con 0-8 regine, **nessuna mincacciata**
	1. Goal-Test: 8 regine sulla scacchiera, nessuna attaccata.
	2. Costo cammino: zero (resta 8, per le 8 mosse effettive, e non è rilevante, interessa solo lo stato finale).
	3. Azioni: aggiungi una regina **nella colonna vuota più a destra ancora libera in modo che non sia minacciata**
	4. Spazio stati: $2057$ possibili sequenze da considerare.
```


```ad-note
title: Formulazione a stato completo
- Stati: scacchiere con 0-8 regine, una per colonna.
	1. Goal-Test: 8 regine già sulla scacchiera, nessuna minacciata
	2. Costo cammino: zero.
	3. Azioni: sposta una regina nella colonna, se minacciata.
```

In generale: $\textit{formulazioni diverse}\implies\textit{spazi di stati diversi}$.

## Ricerca della soluzione
Consiste nella generazione di un albero di ricerca sovrapposto allo spazio degli stati (generato da possibili sequenze di azioni). 

![[romania_1.png]]

```ad-def
title: Ricerca
Approfondire un’opzione, mettere da parte le altre e ripredenderle se non trova soluzione.
```

Espandendo un nodo viene generata una frontiera a partire da esso:

![[romania_2.png]]

### Ricerca ad albero
Ossia senza controllare se i nodi (stati) siano già stati esplorati.

```javascript
function RicercaAlbero (problema) { 
	Inizializza la frontiera con stato iniziale del problema;
	loop do  
		if (la frontiera è vuota)
			return fallimento;  
		Scegli un nodo u foglia da espandere; 
		Rimuovi u dalla frontiera;
		if u contiene uno stato obiettivo
			return soluzione corrispondente;
		Espandi il nodo u;
		Aggiungi i successori di u alla frontiera;
}
```

La scelta del nodo da espandere rappresenta la nostra strategia di ricerca.

### Nodi dell'albero di ricerca
Un nodo $v$ è una struttura dati con quattro componenti:
- **Uno stato.** `v.stato`
- **Nodo padre.** `v.padre`
- **Azione effettuata per generarlo.** `v.azione`
- **Costo del cammino dalla radice a v.** `v.costoCammino` indicata con $g(v)$

$$g(v) = \textit{v.padre.costoCammino}+\textit{costoUltimoPasso}$$

### Struttura dati per la frontiera
```ad-def
title: Frontiera
Lista dei nodi in attesa di essere espansi (le foglie dell’albero di ricerca).
```
La frontiera è implementata come una coda con operazioni:
- `isEmpty()`.
- `pop()`, estrae il primo elemento.
- `push(el, coda)`.

### Strategie di ricerca
```ad-def
title: Breadth-first
Con coda implementata FIFO. Viene estratto l’elemento più vecchio (in attesa da più tempo); in nuovi nodi sono aggiunti alla fine.
```

```ad-def
title: Depth-first
Con coda implementata LIFO. Viene estratto il più recentemente inserito; i nuovi nodi sono inseriti all’inizio (pila).
```

```ad-def
title: UC (uniform cost) e altri...
Con coda con priorità. Viene estratto quello con priorità più alta in base a una funzione di ordinamento; dopo l’inserimento dei nuovi nodi si riordina.
```

Fin'ora abbiamo elencato strategie **non informate**:
- Ricerca in ampiezza (BF)  
- Ricerca in profondità (DF)  
- Ricerca in profondità limitata (DL)  
- Ricerca con approfondimento iterativo (ID) 
- Ricerca di costo uniforme (UC)

### Valutazione di una strategia
- **Completezza**: se la soluzione esiste viene trovata.
- **Ottimalità (ammissibilità)**: trova la soluzione migliore, con costo minore.
- **Complessità in tempo**: tempo richiesto per trovare la soluzione.
- **Complessità in spazio**: memoria richiesta.

## Ricerca BF (in ampiezza)