# Thread che restituiscono risultati
Fin'ora abbiamo visto thread come oggetti che incapsulano attività in modo asincrono (`Runnable`) che implementano il metodo `Run`, quest'ultimo è un metodo **asincrono**, senza parametri e **senza valore di ritorno**.
## Interfaccia Callable
L'interfaccia `Callable` permette di definire tack con risultato (e che sollevino eccezioni). Come accedo al risultato in modo asincrono? Attraverso l'interfaccia `Future` fornita dalla classe `FutureTask`, la prima contiene metodi per reperire (in modo asincrono) il risultato di una computazione asincrona. Cioè metodi per:
1. Controllare se la computazione è terminata.
2. Attendere la terminazione della computazione (eventualmente per un tempo limitato).
3. Per cancellare una computazione.

```java
public interface Callable<V> {
	V call() throws Exception;
}
```
L'interfaccia contiene `Callable` contiene il solo metodo `call()`, analogo al metodo `run()` dell'interfaccia `Runnable`. Il codice del task è implementato nel metodo `call()`. 
```ad-note
title: `call()` vs `run()`
A differenza del metodo `run()`, il metodo `call()` può:
- Restituire un valore.
- Sollevare eccezioni.
- Il parametro di tipo `<V>` indica il tipo del valore restituito (e.g `Callable<Integer>`).
```
### Divide et Impera con multithreading
Calcolare la somma di tutti i numeri da 1 a $n$.
- **Soluzione sequenziale.** Loop che itera da 1 a 100 e calcola la somma.
- **Soluzione Divide and Conquer.**:
	- Individuare sottointervalli dell'intervallo $[1,100]$.
	- Creare un task diverso per ogni intervallo: calcola la somma per quell'intervallo.
	- Sottomettere i task ad un threadpool, ottengo somme parziali in parallelo.
	- Raccogliere le somme parziali per calcolare la somma totale.

```java
import java.util.List;
import java.util.ArrayList; 
import java.util.concurrent.*;
import java.util.concurrent.Callable;
public class Adder {

	public static class Calculator implements Callable<Integer> {
		private int a; 
		private int b;
		
		public Calculator(int a, int b) { 
			this.a = a; 
			this.b = b; 
		}
	
		public Integer call() throws Exception { 
			Thread.sleep((long) (Math.random() * 1000)); 
			return a + b; 
		}
	}
	
	public static void main(String[] args) throws ExecutionException, InterruptedException {
	    // Create thread pool using Executor Framework
	    ExecutorService executor = Executors.newFixedThreadPool(5);
	    List<Future<Integer>> list = new ArrayList<Future<Integer>>();
	    for (int i = 0; i < 10; i += 2) { // Create new Calculator object
		    Calculator c = new Calculator(i, i + 1);
		    list.add(executor.submit(c));
	    }
	    int s = 0;
	    while (!list.isEmpty()){
			for (Future<Integer> f: list) {
				if (f.isDone()) {
				    System.out.println(f.get());
				    s = s + f.get();
				    List.remove(f);
				}
			}
		}
	    System.out.format("la somma è %d.%n", s);
	    executor.shutdown();
	  }
}
```
In una lista di tipo `Future<T>` restituita dai task `Callable` metterò il risultato della submit del task (al thread pool). Così da poter raccogliere i risultati (facendo una `get()`).
## Interfaccia Future
Posso sottomettere direttamente l'oggetto di tipo `Callable` al pool mediante il metodo `submit`. La sottomissione restituisce un oggetto di tipo `Future`, ogni oggetto `Future` è associato ad uno dei task sottomessi al ThreadPool. È possibili applicare diversi metodi all'oggetto `Future`:
```java
public interface Future<V> {
    V get() throws...;
    V get(long timeout, TimeUnit) throws...;
    void cancel(boolean mayInterrupt);
    boolean isCancelled();
    boolean isDone();
}
```
- `get()`. Si blocca fino a che il thread non ha prodotto il valore richiesto e restituisce il valore calcolato.
- `get(long timeout, TimeUnit)`. Definisce un tempo massimo di attesa della terminazione del task, dopo cui viene sollevata una `TimeoutException`.
- `cancel(boolean mayInterrupt)`. Prova a cancellare l'esecuzione di questo task.
- `isCancelled()`. *nomem omen*.
- `isDone()`. *nomem omen*.

## Altri tipi di Thread Pool
### Single Threaded Executor
È un singolo thread $\equiv$ invocare un `FixedThreadPool(1)`. Viene utilizzato per assicurare che i task vengano eseguiti nell'ordine con cui si trovano in coda (sequenzialmente).
### Scheduled Thread Pool
Un ThreadPoolExecutor che può inoltre schedulare comandi da eseguire dopo un determinato delay o da eseguire periodicamente. Viene chiaramente utilizzato per task periodici.
#### Scheduled Executor Service
Interfaccia `ScheduledExecutorService` che da la possibilità di schedulare un task:
- Dopo un certo delay.
- Periodicamente.

```ad-note
title: `schedule(Runnable command, long delay, TimeUnit unit)`
esegue un task `Runnable` (o `Callable`) dopo un certo delay.
```
```ad-note
title: `scheduleAtFixedRate(Runnable command, long initialDelay, long delay, TimeUnit unit)`
esegue un task dopo un intervallo iniziale, poi lo ripete periodicamente. Se il tempo di esecuzione del task è maggiore del periodo specificato, le sue seguenti esecuzioni possono essere ritardate.
```
```ad-note
title: `scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)`
esegue un task dopo un intervallo iniziale, poi lo ripete periodicamente con un intervallo dato tra la terminazione di una esecuzione e l'inizio della successiva.
```
Osserviamo come esempio un programma che periodicamente fa **BEEP**:
```java
import java.util.concurrent.*;
import java.awt.*;
public class BeepClockS implements Runnable {
    public void run() {
        Toolkit.getDefaultToolkit().beep();
    }
    public static void main(String[] args) {
        ScheduledExecutorService scheduler
            = Executors.newSingleThreadScheduledExecutor();
        Runnable task = new BeepClockS();
        int initialDelay = 4;
        int periodicDelay = 2;
        scheduler.scheduleAtFixedRate(task, initialDelay, periodicDelay,
            TimeUnit.SECONDS);
    }
}
```
Osserviamo come esempio un programma che fa partire 3 countdown scaglionati nel tempo:
```java
import java.util.concurrent.*;
public class ConcurrentScheduledTaskExample {

    public static class CountDownClock implements Runnable {
        private String clockName;
        public CountDownClock(String clockName) {
            this.clockName = clockName;
        }
        public void run() {
            String threadName = Thread.currentThread().getName();
            for (int i = 5; i >= 0; i--) {
                System.out.printf("%s -> %s: %d\n", threadName, clockName, i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            }
        }
    }
    
    public static void main(String[] args) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(3);
        CountDownClock clock1 = new CountDownClock("A");
        CountDownClock clock2 = new CountDownClock("B");
        CountDownClock clock3 = new CountDownClock("C");
        scheduler.scheduleWithFixedDelay(clock1, 3, 10, TimeUnit.SECONDS);
        scheduler.scheduleWithFixedDelay(clock2, 3, 15, TimeUnit.SECONDS);
        scheduler.scheduleWithFixedDelay(clock3, 3, 20, TimeUnit.SECONDS);
    }
}
```
## Condividere risorse tra threads: Monitor
Il monitor è un meccanismo linguistico ad alto livello per la sincronizzazione. Incapsula un oggetto condiviso e le operazioni che vengono invocate dai threads su di esso, in modo concorrente.
1. Mutua exlusione garantita
2. Coordinazione tra i thread.
	- Meccanismi per la sospensione sullo stato dell'oggetto condiviso, simili alle *conditional variables*: `wait`.
	- Meccanismi per la notifica di una condizione ai thread sospesi su quella condizione: `notify`/`notifyall`.

Ad ogni oggetto, cioè ad ogni istanza di una classe, viene associata:
- Una **lock implicita**.
	1. Acquisita con metodi o blocchi di codice `synchronized`. Garantisce la mutua esclusione nell'accesso all'oggetto.
	2. Gestione automatica della coda di attesa, da parte della JVM.
![[monitor1.png]]
### Metodi sincronizzati
I metodi di un built-in monitor possono essere resi thread safe annotandoli con la parola chiave `synchronized`.  Osserviamo una coda thread-safe, implementata con monitor: 
```java
public class MessageQueue {
    public MessageQueue(int size)
    public synchronized void produce(Object x)
    public synchronized Object consume()
}
```
L'esecuzione di un metodo `synchronized` richiede automaticamente l'acquisizione della la lock implicita associata all'oggetto. L'intero codice del metodo sincronizzato viene serializzato rispetto agli altri metodi sincronizzati definiti per lo stesso oggetto; solo una thread alla volta può essere eseguire uno dei metodi `synchronized` del monitor sulla stessa istanza di una classe.
```ad-note 
title: Quando viene invocato un metodo sincronizzato
- Tenta di acquisire la lock intrinseca associata all'istanza dell'oggetto su cui esso è invocato.
- se l'oggetto è bloccato il thread viene sospeso nella coda associata all'oggetto fino a che il thread che detiene la lock la rilascia.
- La lock viene rilasciata al ritorno del metodo (normale o con un'eccezione).
```

- I costruttori non devono essere dichiarati `synchronized`, per default, solo il thread che crea l’oggetto accede ad esso mentre l’oggetto viene creato. 
- `synchronized` non è ereditato da overriding. Un metodo nella sottoclasse deve essere esplicitamente definito `synchronized`, se necessario.
- Non ha senso specificare `synchronized` nelle interfacce.
- La lock è associata ad un'istanza dell’oggetto, non alla classe, metodi su oggetti che sono istanze diverse della stessa classe possono essere eseguiti in modo concorrente.

### Metodi per coordinare i thread
Java fornisce 3 metodi di base per coordinare i thread. Appartengono alla classe `Object`.
- Occorre acquisire la lock implicita prima di invocarli, altrimenti viene sollevate l'eccezione `IllegalMonitorException()`.
- Possono essere eseguiti all'interno di metodi sincronizzati.
- Se non si mette il riferimento ad un oggetto, il riferimento implicito è `this`.

```ad-note
title: `void wait()`
Sospende il thread fino a che un altro thread invoca una `notify()`/`notifyAll()`sullo stesso oggetto. Implementa una “attesa passiva” del verificarsi di una condizione. Infinte rilascia la lock sull'oggetto.
```
```ad-note
title: `void notify()`
Sveglia un singolo thread in attesa su questo oggetto. Nop se nessun thread è in attesa.
```
```ad-note
title: `void notifyAll()`
Sveglia tutti i thread in attesa su questo oggetto, che competono per riacquisire della lock.
```

#### Produttore-consumatore con monitor
```java
public class MessageQueue {
    int putptr, takeptr, count;
    final Object[] items;
    public MessageQueue(int size) {
        items = new Object[size];
        count = 0;
        putptr = 0;
        takeptr = 0;
    }
    public synchronized void produce(Object x) {
        while (count == items.length)
            try {
                wait();
            }
        catch (Exception e) {}
        // gestione puntatori coda
        items[putptr] = x;
        putptr++;
        ++count;
        if (putptr == items.length) putptr = 0;
        System.out.println("Message Produced" + x);
        notifyAll();
    }
    public synchronized Object consume() {
	    while (count == 0)
	        try {
	            wait();
	        }
	    catch (InterruptedException e) {}
	    // gestione puntatori coda
	    Object data = items[takeptr];
	    takeptr = takeptr + 1;
	    --count;
	    if (takeptr == items.length) {
	        takeptr = 0;
	    };
	    notifyAll();
	    System.out.println("Message Consumed" + data);
	    return data;
	}
}
```
##### Illustrato
![[pc1.png]]
![[pc2.png]]
![[pc3.png]]
![[pc4.png]]
![[pc5.png]]
![[pc6.png]]
![[pc7.png]]
![[pc8.png]]
![[pc9.png]]
![[pc10.png]]
![[pc11.png]]
![[pc12.png]]
![[pc13.png]]
### Pros/Cons monitor
Pros.
- L'unità di sincronizzazione è il metodo: tutte le sincronizzazioni sono visibili esaminando segnatura dei metodi.
- costrutti strutturati. diminuisce la complessità del programma concorrente.

Cons.
- *coarse grain synchronization* (per-object synchronization) può diminuire il livello di concorrenza.

Le lock esplicite invece permettono maggiore flessibilità (maggior numero di funzioni disponibili), e.g con la `tryLock()` il thread prova ad acquisire una lock ma non mi blocca.
Tuttavia il codice diventa poco leggibile, se usate in modo non strutturato.