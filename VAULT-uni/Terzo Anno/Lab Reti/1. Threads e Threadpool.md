# Thread
## Richiami sui thread
Un thread non è altro che un *light weight process*, un flusso di esecuzione all'interno di un processo. Un processo è controllato dall'OS, il comportamento di un thread (in parte) è controllato dal developer. I thread condividono il medesimo spazio di indirizzamento, il context switch tra thread è meno costoso di quello tra processi così come la comunicazione. 
Su single-core più l'esecuzione di più thread concorrentemente viene risolta con multiplexing oppure interleaving (meccanismi di time sharing tipo RR ecc...). Su multi-core l'esecuzione di più thread può avvenire in parallelo.
Ovviamente condividere risorse tra più thread comporta una maggiore attenzione da parte del developer, per evitare situazioni come deadlock e starvation.
### Thread e rete
Dal punto di vista di un'applicazione client server: più client vengono serviti simultaneamente, l'*i-esimo* client non deve aspettare che il server termini di elaborare la richiesta del client precedente. Il throughput (o capacità di trasmissione) di un'applicazione può essere incrementato se client diversi sono serviti da thread diversi, **MA SOLO FINO A UN CERTO LIMITE**. Oltre quel limite, la concorrenza tra i thread per ottenere la CPU diventa tale (considerando anche i context switch) da far diventare poco vantaggioso il multithreading (costa troppo per quello che mi da). 
Possiamo limitare questo fenomeno con il meccanismo di **threadpooling**.
### In Java
Quando si manda in esecuzione un programma Java, la JVM crea un thread che invoca il metodo `main` del programma; quindi esiste sempre almeno un thread per ogni programma (cioè il `main`). Altri thread sono attivati automaticamente da Java (events handler, garbage collector, ecc...) e la loro esecuzione può creare ed attivare altri thread.
#### Modalità per creare e attivare thread
```ad-note
title: Implements Runnable 
Definiamo un *task*, cioè una classe che implementi l'interfaccia `Runnable`. Poi creiamo un oggetto thread e passiamo come argomento al costruttore il task che abbiamo definito (contiene un metodo `run` con il codice da eseguire) ed infine attiviamo il thread invocando `start()` su quest'ultimo.
```
```java
public class ThreadRunnable {  
	public static class MyRunnable implements Runnable { public void run() {
		System.out.println("MyRunnable running");
		System.out.println("MyRunnable finished"); 
	}

}
	public static void main(String [] args) {  
		Thread thread = new Thread (new MyRunnable()); 
		thread.start();  
	}
}
/* 
Stampa: MyRunnable running
		MyRunnable finished
*/
```
L'interfaccia `Runnable` contiene solo la segnatura del metodo `void run` che deve essere implementato. Un'istanza della classe che implementa `Runnable` è un task, cioè un frammento di codice che può essere eseguito in un thread. La creazione del task non implica la creazione di un thread che lo esegua. Lo stesso task può essere eseguito da più thread. Il task viene passato al Thread che deve eseguirlo.
Posso definire un task anche con classe anonima:
```java
public class RunnableAnonymous {
	public static void main (String[] args) {
		Runnable runnable = new Runnable() {
			public void run() {
				System.out.println("Runnable running");
				System.out.println("Runnable finished");
			}
		};
		Thread t = new Thread(runnable);
		t.start();
	}
}
/* 
Stampa: MyRunnable running
		MyRunnable finished
*/
```
------------------------
```ad-note
title: Extends thread
Creare una classe che estenda `Thread`, effettuare l'overriding del metodo `run()`, istanziare un oggetto di quella classe (l'oggetto sarà un thread il cui comportamento è quello definito nel metodo `run` overridato) e infine invocare il metodo `start`.
```
```java
public class ExtendingThread {
	public static class MyThread extends Thread { 
		public void run() {
			System.out.println("MyThread running"); 
			System.out.println("MyThread finished"); 
		}
	}  
	public static void main (String [] args) {
		MyThread myThread = new MyThread(); 
		myThread.start();
	}
}
/*
Stampa: MyThread running
		MyThread finished
*/
```
La classe `Thread` memorizza un riferimento all'oggetto `Runnable`, eventualmente passato come parametro, nella variabile `runnable`. Definisce il metodo `run()` come segue:
```java
public void run() {
	if (runnable != null) {
		runnable.run();
	}
}
```
Quando viene invocata la `start()`:
	- Se il metodo `run()` è stato ridefinito mediante overriding allora viene invocato il `run()` overridato definito dal programmatore (cioè il più recente).
	- Altrimenti si esegue il metodo `run()` predefinito nella classe `Thread`.
		- Se la variable `runnable` è diversa da `null`, questo metodo a sua volta invoca il metodo `run()` dell'oggetto `Runnable` passato al costruttore del thread.
		- Si esegue il metodo definito dal developer.
#### Esempi thread 
```ad-example
Scrivere un programma che stampi le tabelline moltiplicative dall' 1 al 10:
si attivino 10 threads ogni numero $n$, $1 \leq n \leq 10$, viene passato ad un thread diverso. 
Il task assegnato ad ogni thread consiste nello stampare la tabellina corrispondente al numero che gli è stato passato come parametro.
```
```java
public class Calculator implements Runnable { 
	private int number;  	
	public Calculator(int number) {
	this.number = number; 
	}
	public void run() {
		for (int i=1; i<=10; i++){ 
			System.out.printf("%s: %d * %d = %d\n",
				Thread.currentThread().getName(), number, i, i*number); 
		}
	}
}
```
`Thread.currentThread()` restituisce un riferimento al thread che sta eseguendo il frammento di codice. Il codice del `main`:
```java
public class Main {  
	public static void main(String[] args) {
		for (int i=1; i<=10; i++){  
			Calculator calculator=new Calculator(i);  
			Thread thread=new Thread(calculator); 
			thread.start();
		}  
		System.out.println("Avviato Calcolo Tabelline"); 
	} 
}
/*
Output: 
Thread-0: 1 * 1 = 1 
Thread-9: 10 * 1 = 10 
Thread-5: 6 * 1 = 6 
Thread-8: 9 * 1 = 9 
Thread-7: 8 * 1 = 8 
Thread-6: 7 * 1 = 7 
Avviato Calcolo Tabelline 
Thread-4: 5 * 1 = 5 
Thread-2: 3 * 1 = 3
*/
```
L'output dipende comunque dallo schedulatore della macchina su cui avviamo il programma. Da notare che il messaggio "Avviato Calcolo Tabelline" è stato visualizzato prima che tutti i thread completasserò la loro esecuzione. Perché il controllo ritorna al programma principale, dopo l'attivazione dei thread e **prima** della loro terminazione.
Il fatto che la stampa del messaggio "Avviato Calcolo Tabelline" preceda quelle effettuate dai thread, indica che il controllo è stato restituito al thread chiamante (in questo caso il `main`) prima che sia iniziata l'esecuzione dei thread attivati.
Che succede se al posto di `thread.start()` mettessi `thread.run()`?
```java
public class Main {  
	public static void main(String[] args) {
		for (int i=1; i<=10; i++){  
			Calculator calculator = new Calculator(i);  
			Thread thread = new Thread(calculator); 
			thread.run(); /* sbagliato */
		}  
		System.out.println("Avviato Calcolo Tabelline"); 
	} 
}
/*
main: 1 * 1 = 1 
main: 1 * 2 = 2 
main: 1 * 3 = 3
   .........
main: 2 * 1 = 2
main: 2 * 2 = 4
  .........
Avviato Calcolo Tabelline
*/
```
In pratica non viene attivato nessun thread, ogni metodo `run()` viene eseguito all'interno del flusso del thread attivato per l'esecuzione del programma (`main`). In pratica sequenzializzo l'esecuzione, ragion per cui il messaggio "Avviato Calcolo Tabelline" viene visualizzato dopo l'esecuzione di tutti i metodi `run()` quando il controllo ritorna al programma principale. 
Questa è la dimostrazione che solo il metodo `start()` comporta la creazione di un nuovo thread. Il metodo `start()` segnala allo scheduler (tramite la JVM) che il thread può essere attivato: l'ambiente del thread viene inizializzato, restituisce immediatamente il controllo al chiamante, senza attendere l'inizio dell'esecuzione del thread attivato. 
Lo stesso programma può essere implementato estendendo la classe `Thread`:
```java
public class Calculator extends Thread { 
	private int number;  
	public Calculator(int number) {
		this.number = number; 
	}
	public void run() {  
		for (int i=1; i<=10; i++) {
		System.out.printf("%s: %d * %d = %d\n", 
			Thread.currentThread().getName(),number,i,i*number);
		}
	}
}
public class Main {  
	public static void main(String[] args) {
		for (int i=1; i<=10; i++) {  
			Calculator calculator = new Calculator(i); 
			calculator.start();
		}  
		System.out.println("Avviato Calcolo Tabelline"); 
	} 
}
```
#### Quale modo utilizzare?
In Java abbiamo **ereditarietà singola**: se si estende la classe `Thread`, la classe i cui oggetti devono essere eseguiti come thread non può estendere altre classi.
Questo può risultare svantaggioso quando: 
 * la classe che gestisce un evento deve estendere una classe `C` predefinita di Java.
 * gestione di eventi dell'interfaccia (movimento mouse, input tastiera, ecc...).
 * se il gestore deve essere eseguito in un thread separato, occorrerebbe definire una classe che estenda sia `C` che `Thread`, ma questo non è possibile.
Per questo motivo si definisce una classe che:
* Estenda `C`.
* Implementi l'interfaccia `Runnable`.
#### Terminazione di programmi concorrenti
Un programma Java termina quando terminano tutti i threads non demoni che lo compongono. Se il thread iniziale, cioè quello che esegue il metodo `main()` termina, i restanti thread ancora attivi e non demoni continuano la loro esecuzione, il programma termina quando anche questi terminano. Se uno dei thread usa l'istruzione `System.exit()` per terminare l'esecuzione, allora tutti i threads terminano la loro esecuzione.
## Thread pooling
### Perché usarlo?
Dobbiamo eseguire un gran numero di task (es. un task per ogni client nel server), un thread per ogni task può diventare non sostenibile (specialmente nel caso di task molto frequenti e leggeri). Creando un *pool* di thread, il vantaggio è la possibilità di riutilizzare lo stesso thread per l'esecuzione di più task così da diminuire l'overhead dovuto all'attivazione/terminazione dei threads. È abbastanza banale capire che dobbiamo stabilire un limite superiore per il numero di thread che possono essere eseguiti concorrentemente.
### Come viene implementato?
Abbiamo: una coda (FIFO) di task che aspettano la loro esecuzione e un pool di thread disponibili per l'esecuzione di un task. Il sistema di gestione del threadpool chiede se esiste un thread libero per l'esecuzione del primo task della coda.
	- Se c'è un thread libero, allora il primo task della coda viene assegnato al thread e il thread ora occupato viene rimosso dal Pool.
	- Se tutti i thread sono occupati (quindi il Pool è vuoto) abbiamo due alternative:
   1. Il task successivo viene inserito nella coda, in attesa che si renda disponibile un thread.
	2.  Si crea un nuovo thread all'interno del threadpool da assegnare alla task.

Nel primo caso il comportamento descritto è quello del `FixedThreadPool` di Java.
### Terminologia
L'utente struttura l'applicazione mediante un insieme di tasks. Un Thread Pool è una struttura dati la cui dimensione può essere fissata, contiene riferimenti ad un insieme di threads. I thread del Pool possono essere riutilizzati per l'esecuzione di più tasks. La sottomissione di un task al pool viene **disaccoppiata** dall'esecuzione del thread. L'esecuzione del task può essere ritardata se non vi sono risorse disponibili.
### Che dobbiamo fare?
* Creare il Pool.
* Stabilire una politica per la gestione dei thread del Pool.
* Quando i thread vengono attivati (on demand, quando arriva un task, ecc...).
* Se e quando è opportuno terminare l'esecuzione di un thread (quando non ci sono più task, ecc...).
* Sottomettere i task per l'esecuzione al thread Pool.
Una task per il meccanismo di Thread Pooling deve per forza implementare `Runnable`.
### Fixed Thread Pool
È un tipo di threadpool con comportamento predefinito, viene creato un numero fisso di thread $n$ con $n$ fissato al momento dell'inizializzazione del pool. Un thread viene riutilizzato per l'esecuzione di più task.
Quando viene sottomesso un task $T$ :
* Se tutti i threads sono occupati nell'esecuzione di altri tasks $\implies T$ viene inserito in una coda, gestita automaticamente dall'`ExecutorService`.
* Se almeno un thread è inattivo, viene utilizzato quel thread.
In particolare viene utilizzata una coda illimitata `LinkedBlockingQueue`.
```java
import java.util.concurrent.Executors; 
import java.util.concurrent.ExecutorService; 
public class ExampleFixed{
	public static void main(String[] args) { 
		// create the pool  
		ExecutorService service = Executors.newFixedThreadPool(10); 
		//submit the task for execution  
		for (int i =0; i<100; i++) {
			service.execute(new Task(i)) 
		} 
		System.out.println("Thread Name:"+ Thread.currentThread().getName()); 
	}
}
/*
OUTPUT:
Thread Name:main 
 pool-1-thread-7: Task 6: Starting during 6 
 pool-1-thread-9: Task 8: Starting during 9 
 pool-1-thread-8: Task 7: Starting during 7 
 pool-1-thread-10: Task 9: Starting during 9 
 pool-1-thread-2: Task 1: Starting during 9 
 pool-1-thread-4: Task 3: Starting during 9 
 pool-1-thread-1: Task 0: Starting during 1 
 pool-1-thread-6: Task 5: Starting during 0 
 pool-1-thread-3: Task 2: Starting during 9 
 pool-1-thread-5: Task 4: Starting during 3 
 pool-1-thread-6: Task Finished 5 
 pool-1-thread-6: Task 10: Starting during 9 
 pool-1-thread-1: Task Finished 0 
 pool-1-thread-1: Task 11: Starting during 3 
 pool-1-thread-5: Task Finished 4 
 pool-1-thread-5: Task 12: Starting during 5 
 pool-1-thread-1: Task Finished 11 
 pool-1-thread-7: Task Finished 6 
 pool-1-thread-1: Task 13: Starting during 1 
 pool-1-thread-7: Task 14: Starting during 2 
 ...
*/
```
Se inserissimo una `sleep` per distanziare la sottomissione dei task ai thread (nel for dopo la `execute(new Task(i))`): i thread sono tutti attivi e vengono utilizzati in modalità RR (come si danno le carte a poker).
### Cached Thread Pool
È un thread pool elastico, si allarga e si stringe. Posso creare un thread ed aggiungerlo alla pool se me ne serve uno libero per una task. I thread vengono uccisi (rimossi dal pool) per inattività (thread sta in *idle* per un quanto di tempo).
```java
import java.util.concurrent.Executors; 
import java.util.concurrent.ExecutorService; 
public class ExampleCached{
	public static void main(String[] args) {  
		ExecutorService service = Executors.newCachedThreadPool(); 
		for (int i =0; i<100; i++) {
			service.execute(new Task(i)); sleep(1000); 
		} 
		System.out.println("ThreadName:"+Thread.currentThread().getName());
	}  
	private static void sleep(long timeMillis) {
		try { 
			Thread.sleep(timeMillis);
		} catch(InterruptedException e) {;}
	}
}
```
Viene attivato un nuovo thread per ogni nuovo task
```
OUTPUT CACHED THREAD POOL
 pool-1-thread-11: Task 10: Starting during 5 
 pool-1-thread-100: Task 99: Starting during 5 
 Thread Name:main 
 pool-1-thread-99: Task 98: Starting during 7 
 pool-1-thread-98: Task 97: Starting during 7 
 pool-1-thread-97: Task 96: Starting during 6 
 pool-1-thread-96: Task 95: Starting during 6 
 pool-1-thread-95: Task 94: Starting during 9 
 pool-1-thread-94: Task 93: Starting during 2 
 pool-1-thread-93: Task 92: Starting during 3 
 pool-1-thread-92: Task 91: Starting during 0 
 pool-1-thread-92: Task Finished 91 
 pool-1-thread-91: Task 90: Starting during 8 
 pool-1-thread-90: Task 89: Starting during 6 
 pool-1-thread-89: Task 88: Starting during 6 
 pool-1-thread-88: Task 87: Starting during 1 
 pool-1-thread-87: Task 86: Starting during 3 
 pool-1-thread-86: Task 85: Starting during 7 
 pool-1-thread-85: Task 84: Starting during 7 
 pool-1-thread-84: Task 83: Starting during 7 
 pool-1-thread-83: Task 82: Starting during 4 
 pool-1-thread-82: Task 81: Starting during 8 
```
Se invece distanziassi la sottomissione dei task ai thread mettendo una `sleep` dopo nel for (dopo la `execute()`):
```
pool-1-thread-1: Task 0: Starting during 3 seconds 
pool-1-thread-1: Task Finished 0 
pool-1-thread-1: Task 1: Starting during 7 seconds 
pool-1-thread-1: Task Finished 1 
pool-1-thread-1: Task 2: Starting during 0 seconds 
pool-1-thread-1: Task Finished 2 
pool-1-thread-1: Task 3: Starting during 3 seconds 
pool-1-thread-1: Task Finished 3 
pool-1-thread-1: Task 4: Starting during 5 seconds 
pool-1-thread-1: Task Finished 4 
pool-1-thread-1: Task 5: Starting during 5 seconds
pool-1-thread-1: Task Finished 5 
pool-1-thread-1: Task 6: Starting during 9 seconds 
pool-1-thread-1: Task Finished 6 
pool-1-thread-1: Task 7: Starting during 6 seconds 
pool-1-thread-1: Task Finished 7 
pool-1-thread-1: Task 8: Starting during 1 seconds 
pool-1-thread-1: Task Finished 8 
pool-1-thread-1: Task 9: Starting during 1 seconds 
pool-1-thread-1: Task Finished 9 
pool-1-thread-1: Task 10: Starting during 0 seconds"
```
Ora viene utilizzato sempre il thread $1$ per tutti i task.
## Richiami su I/O
La maggior parte dell'I/O fondamentale in Java si basa su **streams**. Uno stream rappresenta un flusso di dati con (almeno concettualmente) un writer a un'estremità e un reader all'altra. Quando si lavora con il pacchetto `jave.io` per eseguire l'input e l'output da terminale, la lettura o la scrittura di file o la comunicazione attraverso i socket in Java, si utilizzano vari tipi di stream. Tra cui:
* `InputStream`, `OutPutStream`. Classi astratte che definiscono la funzionalità di base per leggere o scrivere una sequenza non strutturata di byte. Tutti gli altri stream di byte in Java sono costruiti sulla base di `InputStream` e `OutputStream`.

* `Reader`, `Writer`. Classi astratte che definiscono la funzionalità di base per la lettura o la scrittura di una sequenza di dati di caratteri, con supporto per Unicode. Tutti gli altri stream di caratteri in Java si basano su `Reader` e `Writer`.

* `InputStreamReader`, `OutputStreamWriter`. Classi che collegano stream di byte e di caratteri convertendoli secondo uno specifico schema di codifica dei caratteri. (in Unicode, un carattere non è necessariamente un byte).

* `DataInputStream`, `DataOutputStream`. Stream filters che aggiungono la capacità di leggere e scrivere tipi di dati multibyte, come primitive numeriche e oggetti String in un formato universale.

* `ObjectInputStream`, `ObjectOutputStream`. Stream filters in grado di scrivere interi gruppi di oggetti Java serializzati e di ricostruirli.

* `BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, `BufferedWriter`. Stream filters che aggiungono il buffering per una maggiore efficienza. Per l'I/O del mondo reale, si usa quasi sempre un buffer.

* `PrintStream`, `PrintWriter`. Stream filters che semplificano la stampa di un testo.

* `PipedInputStream`, `PipedOutputStream`, `PipedReader`, `PipedWriter`. Loopback stream che possono essere usati in coppia per spostare dati all'interno di un'applicazione. I dati scritti in un `PipedOutputStream` o `PipedWriter` vengono letti dal `PipedInputStream` o `PipedReader` corrispondente.

* `FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`. Implementazioni di InputStream, OutputStream, Reader e Writer che leggono e scrivono su file del filesystem locale.

I stream in Java sono unidirezionali. ![[io_java.png]]
La classe `java.lang.System`, un repository generale per le risorse relative al sistema, fornisce un riferimento allo stream di standard input nella variabile statica `System.in`. Stessa cosa per output ed error nelle variabili `out` e `err`, rispettivamente. L'esempio seguente mostra la corrispondenza:
```java
InputStream stdin = System.in;
OutputStream stdout = System.out;
OutputStream stderr = System.err;
```
Possiamo leggere un singolo byte alla volta dallo standard input con il metodo `read()` di `InputStream`.
```java
try {  
	int val;
while( (val=System.in.read()) != -1 ) 
	System.out.println((byte)val);
} catch ( IOException e ) { ... }
```
Si può anche verificare il numero di byte disponibili per la lettura in un dato momento su un `InputStream`, utilizzando il metodo `available()`.
```java
int waiting = System.in.available(); 
if(waiting>0){
	byte [] data = new byte [ waiting ]; 
	System.in.read( data );  
	...
}
```
I metodi `read()` si bloccano finché non viene letto almeno un dato (almeno un byte). In generale, è necessario controllare il valore restituito per determinare quanti dati sono stati letti e se è necessario leggerne altri. Il metodo `close()` chiude lo stream e libera le risorse di sistema associate.
### Wrappers o Filtri
Si può usare un filter stream, che è un tipo di `InputStream`, `OutputStream`, `Reader` o `Writer` che wrappa un altro flusso e aggiunge nuove funzionalità. Un filter stream prende lo stream di destinazione come argomento nel suo costruttore e delega le chiamate ad esso dopo aver effettuato alcune elaborazioni aggiuntive. Ad esempio, possiamo costruire un `putStream BufferedIn` per wrappare lo standard input del sistema:
```java 
InputStream bufferedIn = new BufferedInputStream( System.in );
```
Il `BufferedInputStream` è un tipo di filter stream che legge in anticipo e bufferizza una certa quantità di dati. Wrappa un ulteriore livello di funzionalità attorno allo stream sottostante.
![[filter_stream.png]]
#### Data streams
`DataInputStream` e `DataOutputStream` sono filter streams che consentono di leggere o scrivere stringhe e tipi di dati primitivi composti da più di un singolo byte. Implementano rispettivamente le interfacce `DataInput` e `DataOutput`. Queste interfacce definiscono i metodi per leggere o scrivere stringhe e tutti i tipi di dati primitivi di Java.
È possibile costruire un `DataInputStream` da un `InputStream` e poi usare un metodo come `readDouble()` per leggere un tipo di dati primitivo:
```java
DataInputStream dis = new DataInputStream( System.in ); 
double d = dis.readDouble();
```
Abbiamo wrappato lo stream standard input in un `DataInputStream` e lo abbiamo usato per leggere un valore `double`.
#### Buffered streams
Le classi `BufferedInputStream`, `BufferedOutputStream`, `BufferedReader` e `Buffered Writer` aggiungono al percorso dello stream un buffer di dati di dimensioni specifiche. Un buffer può aumentare l'efficienza riducendo il numero di operazioni fisiche di lettura o scrittura che corrispondono alle chiamate ai metodi `read()` o `write()`. Si crea un flusso bufferizzato con un flusso di ingresso o di uscita appropriato e una dimensione del buffer. (È anche possibile wrappare un altro stream attorno a un buffered stream, in modo che benefici del buffering).
```java
// buffer di 32KB
BufferedInputStream bis = new BufferedInputStream(myInputStream, 32768); 
...  
bis.read();
```
Alla prima chiamata a `read()`, `bis` cerca di riempire l'intero buffer di 32 KB con i dati, se disponibili. In seguito, le chiamate a `read()` recuperano i dati dal buffer, che viene riempito se necessario. Un `BufferedOutputStream` funziona in modo simile. Le chiamate a `write()` memorizzano i dati in un buffer; i dati vengono effettivamente scritti solo quando il buffer si riempie. È inoltre possibile utilizzare il metodo `flush()` per eliminare il contenuto di un `BufferedOutputStream` in qualsiasi momento. Il metodo `flush()` è in realtà un metodo della classe `OutputStream` stessa. Consente di essere sicuri che tutti i dati contenuti negli stream sottostanti e nei filter stream siano stati inviati.