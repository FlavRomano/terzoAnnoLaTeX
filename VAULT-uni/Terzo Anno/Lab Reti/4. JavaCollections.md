# JavaCollections
## Java Iterators
> Fornire un modo per accedere agli elementi di un oggetto aggregato in modo sequenziale senza esporre la sua rappresentazione sottostante.
> -- <cite>The Gang Of Four</cite>

Gli iteratori vengono usati per accedere agli elementi di una collezione, uno alla volta. Un iteratore deve conoscere (e poter accedere) alla rappresentazione interna della classe che implementa la collezione.
L’interfaccia `Collection` contiene il metodo `iterator()` che restituisce un iteratore per una collezione.
- le diverse implementazioni di `Collection` implementano il metodo `iterator()` in modo diverso.
- l’interfaccia `Iterator` prevede tutti i metodi necessari per usare un iteratore, senza conoscere alcun dettaglio implementativo.

Esempio d'uso di un iteratore:
```java
import java.util.*;
public class PersonList {
    public static void main(String args[]) {
        Person Tom = new Person("Tom", 45, "professor");
        Person Harry = new Person("Harry", 20, "student");
        List<Person> pList = new LinkedList<Person>();
        // ...
        Iterator<Person> tIterator = pList.iterator();
        while (tIterator.hasNext()) {
            Person tPerson = (Person) tIterator.next();
            System.out.println(tPerson);
        }
    }
}
```
```ad-note
title: Osservazioni
- l’iteratore non ha alcuna funzione che lo “resetti”.
- una volta iniziata la scansione, non si può fare tornare indietro l’iteratore.
- una volta finita la scansione, è necessario creare uno nuovo iteratore.
```
Esempio d'uso di un iteratore **su HashMap**:
```java
import java.util.*;

public class Employee {
    private String id;
    private String name;
    private String department;
    public Employee(String id, String name, String department) {
        this.id = id;
        this.name = name;
        this.department = department;
    }
    public String toString() {
		return String.format("[%s : %s : %s]", id, name, department);
    }
	public class EmployeeIterator {
    public static void main(String args[]) {
        HashMap<String, Employee> employeeMap = new HashMap<String, Employee> ();
        employeeMap.put("emp01", new Employee("emp01", "Tom", "IT"));
        employeeMap.put("emp02", new Employee("emp02", "Jhon", "Supply Chain"));
        employeeMap.put("emp03", new Employee("emp03", "Oliver", "Marketing"));
        employeeMap.put("emp04", new Employee("emp04", "Mary", "IT"));
        Set<Map.Entry<String,Employee>> entrySet = employeeMap.entrySet();
        Iterator<Map.Entry<String, Employee>> iterator = entrySet.iterator();
        System.out.println("Iterate through mappings of HashMap");
        while (iterator.hasNext()) {
            Map.Entry < String, Employee > entry = iterator.next();
            System.out.println(entry.getKey() + " => " + entry.getValue());
        }
    }
}
}
```
##  Thread Safeness
Le collezioni non thread safe, non offrono alcun supporto per la sincronizzazione dei threads:
- `java.util.Map`.
- `java.util.LinkedList`.
- `java.util.ArrayList`.
Java offre thread safe collections, sincronizzate automaticamente:
- `java.util.Vector`.
- `java.util.Hashtable`.
- synchronized collections.
- concurrent collections di `java.util.concurrent`.
```ad-note
title: `ArrayList` non è threadsafe
`add` non è una operazione atomica perché:
1. determina quanti elementi ci sono nella lista.
2. determina il punto esatto del nuovo elemento. 
3. incrementa il numero di elementi della lista.
4. se si eseguono due `add` in modo concorrente lo stato della struttura può essere inconsistente.

Stessa cosa per la `remove`.
```
## Synchronized Collection
Java fornisce dei **synchronized collection wrappers** che:
- *incapsulano* ogni metodo in un blocco sincronizzato.
- trasformano una Collection non thread safe in una thread-safe.
- utilizzano un'unica lock implicita per tutta la collezione, gestita dalla JVM.
- si parla di *conditionally thread safeness*.

| Metodi di `Collections` |
| -- |
| `synchronizedCollection(coll)` |
| `synchronizedCollection(list)`| 
| `synchronizedCollection(map)`| 

Esempio di synchronized collection:
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Collections;

public class VectorArrayList {
    public static void addElements(List<Integer> list) {
        for (int i = 0; i < 1000000; i++) {
            list.add(i);
        }
    }
    public static void main(String args[]) {
        final long start1 = System.nanoTime();
        addElements(new ArrayList<Integer>());
        final long end1 = System.nanoTime();
        final long start2 = System.nanoTime();
        addElements(Collections.synchronizedList(new ArrayList<Integer>()));
        final long end2 = System.nanoTime();
        System.out.println("ArrayList time " + (end1 - start1));
        System.out.println("SynchronizedArrayList time " + (end2 - start2));
    }
}
```
### Classi *Conditionally Thread Safe*
La thread safety garantisce che la safety delle singole operazioni operazioni sulla collezione, ma **funzioni che coinvolgono più di una operazione** possono non essere thread-safe.
Vector è una collezione thread-safe, però perchè in caso di accessi concorrenti, questo programma genera `ArrayIndexOutOfBoundsException`.
![[unsafeVector.png]]
```java
public class UnsafeVector {
    public static < T > T getLast(Vector<T> list) {
        int lastIndex = list.size() - 1;
        return (list.get(lastIndex));
    }
    public static void deleteLast(Vector<T> list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}
```
```ad-note
title: `isEmpty()` e `remove(int)`
Sono entrambe operazioni atomiche, ma la loro combinazione non lo è.
Un possibile scenario d'errore è:
1. Una lista con un solo elemento.
2. Il primo thread verifica che la lista non è vuota e viene deschedulato prima di rimuovere l'elemento.
3. Un secondo thread rimuove l'elemento, il primo thread torna in esecuzione e prova a rimuovere un elemento non esistente
```
Java Synchronized Collections sono **conditionally thread-safe**:
> le operazioni individuali sulle collezioni sono safe, ma funzioni composte da più di una operazione singola possono risultarlo.

### Uso dei blocchi sincronizzati
Può essere richiesta una sincronizzazione esplicita da parte del programmatore per sincronizzare una sequenza di operazioni: 
```java
synchronized(syncList) {
	if(!synchList.isEmpty()) { synchList.remove(0); }
}
```
Il thread che esegue l'operazione composta acquisisce la lock sulla struttura synchList più di una volta:
- Quando esegue il blocco sincronizzato.
- Quando esegue i metodi della collezione.

Ma il comportamento corretto è garantito perchè le lock sono **rientranti**:
> *Lock rientrante*: può essere acquisita più volte dallo stesso processo o thread (di esecuzione) senza causare un deadlock. 

Esempio d'uso dei blocchi sincronizzati:
```java
@ThreadSafe
public class UnsafeVector {
    public static <T> T getLast(Vector<T> list) {
        synchronized(list) {
            int lastIndex = list.size() - 1;
            return (list.get(lastIndex));
        }
    }
    public static void deleteLast(Vector<T> list) {
        synchronized(list) {
            int lastIndex = list.size() - 1;
            list.remove(lastIndex);
        }
    }
}
```
### Iteratori ed eccezioni
Un'eccezione viene sollevata dagli iteratori su collezioni se la collezione viene modificata prima che l'iterazione sia completata; anche se il programma è sequenziale:
```java
for (E element: list)
    if (isBad(element))
        list.remove(element) //ConcurrentModificationException
```
anche se la collezione è sincronizzata, l'iteratore su di essa può non esserlo:
```java
synchronized(syncList) {
    Iterator iterator = syncList.iterator();
    // do stuff with the iterator here
}
```
## Concurrent Collections
La *fine-grain locking*, non bloccano l'intera collezione:
