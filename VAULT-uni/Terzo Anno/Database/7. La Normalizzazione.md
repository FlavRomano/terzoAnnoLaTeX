La normalizzazione è fondamentale nella teoria della progettazione relazionale.
Per produrre un nuovo schema relazionale ci sono due modi:
1. Partire da un buono schema ad oggetti e **tradurlo**
2. Partire da uno schema relazionale già esistente e modificarlo o completarlo

questo processo non esclude la formazione di [[Anomalia|anomalie]] all'interno dello schema finale, tocca eliminarle attraverso la **normalizzazione**.

Noi assumiamo l'ipotesi dello [[schema di relazione universale]]. 

Lo **schema di relazione universale $U$** di una base di dati relazionale ha come attributi  **l'unione degli attributi** di tutte le relazioni della base di dati.

## Tabella fatta male 
Data una tabella, come si può dire che è fatta male? E come la si corregge?
e.g: 
- StudentiEdEsami(Matricola, Nome, Provincia, AnnoNascita, Materia, Voto)

Abbiamo le seguenti anomalie:
- **Ridondanze**
	- con la matricola trasportiamo un'informazione più precisa del nome per identificare lo studente
- **Potenziali inconsistenze**
	- se uno studente non ha dato nessun esame, o Materia con il Voto è `NULL` oppure non può esistere in tabella
- **Anomalie nelle inserzioni/eliminazioni**

Una soluzione è **dividere lo schema in due tabelle**:
- Studenti(<u>Matricola</u>, Nome,  Provincia, AnnoNascita)
- Esami(<u>Matricola</u>, Materia, Voto)

## Forme normali
Una [[Forma normale|forma normale]] è una proprietà di una base di dati relazionale che ne garantisce qualità, cioé l'assenza di determinati difetti.
- Quando una relazione **non è normalizzata**
	- presenta **ridondanze**
	- si presta a comportamenti **indesiderati durante gli aggiornamenti**

La normalizzazione è una procedura che permette di **trasformare schemi non normalizzati** in schemi  che soddisfano una **forma normale**.

Quindi in generale vogliamo evitare [[fenomeni indesiderati]].
## Linee guida per una corretta progettazione
### Semantica degli attributi
Ogni schema relazionale che progettiamo deve essere **semplice da spiegare**
> Non si uniscano attributi provenienti da più tipi di classi e tipi di associazione in un'unica relazione.

### Ridondanza 
Ogni schema relazionale che progettiamo deve avere relazioni **senza anomalie di inserimento, cancellazione o modifica**. Tuttavia alcune di queste anomalie possono essere mantenute, l'importante è rilevarle e assicurarsi che i programmi aggiornino la base di dati correttamente.

### Valori nulli
Si eviti di porre in **relazione di base** attributi in cui i valori possono **essere frequentamente nulli**. Se ciò è inevitabile, bisogna assicurarsi che si presentino solo in casi eccezionali (non devono riguardare molte ennuple della relazione).

### Tuple spurie
Gli schemi relazionali che progettiamo devono poter essere **riuniti da una [[JOIN SQL|JOIN]]**
- con **condizioni di uguaglianza** su attributi che sono
	- [[chiave#Chiave Primaria|chiavi primarie]]
	- oppure [[chiave#Chiave esterna|chiavi esterne]]

così da poter evitare [[tuple spurie]]. Vogliamo garantire che facendo una joi abbiamo lo stesso numero di tuple.

## Dipendenze funzionali
Per formalizzare la nozione di **schema senza anomalie** occorre una descrizione formale della **semantica dei fatti** rappresentati in uno schema relazionale.

Si parla quindi di [[istanza valida]] e di [[dipendenza funzionale]]. 

Dato uno schema $R(T)$ e $X,Y\subset T$, una [[dipendenza funzionale]] è un vincolo su $R$ del tipo $X\to Y$, si dice che

**un'istanza** $r_{0}\in R$
-  **soddisfa** la dipendenza funzionale $X\to Y$ $$r_{0}\vDash X\to Y$$ se la proprietà vale per ogni coppia di tuple in $r_{0}$, cioé $$\forall\; t_{1}[X]=t_{2}[X] \implies t_{1}[Y]=t_{2}[Y]$$
- **soddisfa un insieme** $F$ di dipendenze funzionali $$\text{se per ogni }X\to Y\in F \text{ vale }r_{0}\vDash X\to Y$$ cioé $r_{0}\vDash X \to Y \iff \forall\; t_{1}[X]=t_{2}[X] \implies t_{1}[Y]=t_{2}[Y]$ come detto nel punto sopra.

n.b: $r_{0}\vDash X\to Y$ vuol dire che l'istanza $r_{0}$ **soddisfa** la dipendenza funzionale $X\to Y$

### Esempio 
In questa relazione vengono rappresentate **informazioni eterogenee** assieme
![[Pasted image 20230825191240.png]]

- Gli impiegati e i relativi stipendi $Impiegato\to Stipendio$
- I progetti con i relativi bilanci $Progetto\to Bilancio$
- Le partecipazioni degli impiegati ai progetti con le relative funzioni $Impiegato, Progetto\to Funzione$

### Esprimere le dipendenze funzionali
Abbiamo vari modi di esprimere le dipendenze funzionali in queste forme a clausole:
- [[Espressione diretta]]
- [[Contrapposizione]]
- [[Per assurdo]]

tutte le clausole con cui esprimiamo le dipendenze funzionali sono **equivalenti**
$$A\implies B \iff A \land \lnot B \implies False \iff \lnot B \implies \lnot A$$
in generale in ogni clausola $A\land B \implies E\lor F$ posso spostare le sottoformule da un lato all'altro **negandole**.

Quindi sono equivalenti:
- DotazioniLibri(CodiceLibro, NomeNegozio, IndNegozio, Titolo, Quantità) 
	- $NomeNegozio_{=}\land CodiceLibro_{=}\implies Quantità_{=}$
	- $NomeNegozio_{=}\land CodiceLibro_{=}\land Quantità_{\ne} \implies False$
	- $CodiceLibro_{=}\land Quantità_{\ne}\implies NomeNegozio_\ne$
	- $NomeNegozio_{=} \implies CodiceLibro_{\ne}\land Quantità_{=}$

**IMPORTANTE**: Rappresentiamo le dipendenze funzionali come **congiunzione di clausole**, quindi possiamo manipolarle e ottenere risultati seguendo la logica proposizionale. 
Ricorda che:
- passando da un membro all'altro una clausola questa viene **negata** 
- e di conseguenza un'[[Espressione diretta|espressione diretta]] diventa [[Contrapposizione|contrapposizione]] e viceversa.